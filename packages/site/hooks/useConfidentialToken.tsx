"use client";

import { ethers, parseUnits, formatUnits } from "ethers";
import {
  RefObject,
  useCallback,
  useEffect,
  useMemo,
  useRef,
  useState,
} from "react";

import { FhevmInstance } from "@/fhevm/fhevmTypes";
import { FhevmDecryptionSignature } from "@/fhevm/FhevmDecryptionSignature";
import { GenericStringStorage } from "@/fhevm/GenericStringStorage";

export type ClearValueType = {
  handle: string;
  clear: string | bigint | boolean;
};

type ConfidentialTokenInfoType = {
  abi: any; // Will be generated by genabi script
  address?: `0x${string}`;
  chainId?: number;
  chainName?: string;
};

/*
  The following two files are automatically generated by the script located at 
  <root>/scripts/genabiConfidentialToken.mjs. This script parses the 
  <root>/packages/fhevm-hardhat-template/deployments directory to retrieve 
  deployment information for ConfidentialToken.sol:
  
  - <root>/packages/site/abi/abi/ConfidentialTokenABI.ts
  - <root>/packages/site/abi/abi/ConfidentialTokenAddresses.ts
*/
import { ConfidentialTokenFixedAddresses } from "@/abi/ConfidentialTokenFixedAddresses";
import { ConfidentialTokenFixedABI } from "@/abi/ConfidentialTokenFixedABI";
import { ConfidentialTokenExtendedABI } from "../abi/ConfidentialTokenExtendedABI";
import { CTRegistryABI } from "@/abi/CTRegistryABI";
import { CTRegistryAddresses } from "@/abi/CTRegistryAddresses";

/**
 * Resolves ConfidentialToken contract metadata for the given EVM `chainId`.
 *
 * The ABI and address book are **generated** from the `fhevm-hardhat-template`
 * artifacts into the `@/abi` folder at build time. This function performs a
 * simple lookup in that generated map.
 *
 * Behavior:
 * - If `chainId` is `undefined` or not found in the map, returns ABI only.
 * - Otherwise returns `{ abi, address, chainId, chainName }`.
 *
 * @param chainId - Target chain id (e.g., 1, 5, 11155111). `undefined` returns ABI-only.
 * @returns Contract info for the chain or ABI-only fallback.
 * @example
 * const { abi, address } = getConfidentialTokenByChainId(chainId);
 */
function getConfidentialTokenByChainId(
  chainId: number | undefined
): ConfidentialTokenInfoType {
  if (!chainId) {
    return { abi: ConfidentialTokenExtendedABI.abi };
  }

  // Registry lookup will be handled by the hook when needed
  // No localStorage dependency anymore

  // Fallback to generated addresses (deployed from Hardhat)
  const entry =
    ConfidentialTokenFixedAddresses[chainId.toString() as keyof typeof ConfidentialTokenFixedAddresses];

  if (!("address" in entry) || entry.address === ethers.ZeroAddress) {
    return { abi: ConfidentialTokenFixedABI.abi, chainId };
  }

  return {
    address: entry?.address as `0x${string}` | undefined,
    chainId: entry?.chainId ?? chainId,
    chainName: entry?.chainName,
    abi: ConfidentialTokenExtendedABI.abi,
  };
}

function getNetworkName(chainId: number): string {
  switch (chainId) {
    case 1: return "Ethereum Mainnet";
    case 11155111: return "Sepolia Testnet";
    case 31337: return "Hardhat Local";
    default: return `Chain ${chainId}`;
  }
}

/**
 * Lookup contract address from Registry
 */
async function lookupFromRegistry(
  ownerAddress: string,
  slug: string = "main",
  chainId: number,
  provider: any
): Promise<string | null> {
  try {
    const registryEntry = CTRegistryAddresses[chainId.toString() as keyof typeof CTRegistryAddresses];
    if (!registryEntry || registryEntry.address === "0x0000000000000000000000000000000000000000") {
      return null;
    }

    const registry = new (await import("ethers")).Contract(
      registryEntry.address,
      CTRegistryABI.abi,
      provider
    );

    const tokenAddress = await registry.latest(ownerAddress, slug);
    return tokenAddress;
  } catch (error) {
    console.error("Registry lookup failed:", error);
    return null;
  }
}

/**
 * React hook for interacting with ConfidentialToken contract
 * Provides functionality for:
 * - Minting confidential tokens
 * - Transferring confidential tokens
 * - Decrypting own balance
 * - Initializing addresses
 */
export const useConfidentialToken = (parameters: {
  instance: FhevmInstance | undefined;
  fhevmDecryptionSignatureStorage: GenericStringStorage;
  eip1193Provider: ethers.Eip1193Provider | undefined;
  chainId: number | undefined;
  ethersSigner: ethers.JsonRpcSigner | undefined;
  ethersReadonlyProvider: ethers.ContractRunner | undefined;
  sameChain: RefObject<(chainId: number | undefined) => boolean>;
  sameSigner: RefObject<
    (ethersSigner: ethers.JsonRpcSigner | undefined) => boolean
  >;
}) => {
  const {
    instance,
    fhevmDecryptionSignatureStorage,
    chainId,
    ethersSigner,
    ethersReadonlyProvider,
    sameChain,
    sameSigner,
  } = parameters;

  //////////////////////////////////////////////////////////////////////////////
  // States + Refs
  //////////////////////////////////////////////////////////////////////////////

  const [balanceHandle, setBalanceHandle] = useState<string | undefined>(undefined);
  const [clearBalance, setClearBalance] = useState<ClearValueType | undefined>(
    undefined
  );
  const clearBalanceRef = useRef<ClearValueType>(undefined);
  const [isRefreshing, setIsRefreshing] = useState<boolean>(false);
  const [isDecrypting, setIsDecrypting] = useState<boolean>(false);
  const [isMinting, setIsMinting] = useState<boolean>(false);
  const [isTransferring, setIsTransferring] = useState<boolean>(false);
  const [isInitializing, setIsInitializing] = useState<boolean>(false);
  const [message, setMessage] = useState<string>("");
  const [lookedUpTokenAddress, setLookedUpTokenAddress] = useState<string | null>(null);
  const [contractOwner, setContractOwner] = useState<string | null>(null);
  const [isOwner, setIsOwner] = useState<boolean>(false);
  const [currentSlug, setCurrentSlug] = useState<string>("tomcat2389");
  const [debouncedSlug, setDebouncedSlug] = useState<string>("tomcat2389");
  const [availableSlugs, setAvailableSlugs] = useState<string[]>([]);

  const confidentialTokenRef = useRef<ConfidentialTokenInfoType | undefined>(undefined);
  const isRefreshingRef = useRef<boolean>(isRefreshing);
  const isDecryptingRef = useRef<boolean>(isDecrypting);
  const isMintingRef = useRef<boolean>(isMinting);
  const isTransferringRef = useRef<boolean>(isTransferring);
  const isInitializingRef = useRef<boolean>(isInitializing);

  const isDecrypted = balanceHandle && balanceHandle === clearBalance?.handle;

  // Debounce slug changes to avoid too many registry lookups
  useEffect(() => {
    const timer = setTimeout(() => {
      setDebouncedSlug(currentSlug);
    }, 500); // 500ms delay

    return () => clearTimeout(timer);
  }, [currentSlug]);

  //////////////////////////////////////////////////////////////////////////////
  // ConfidentialToken Contract
  //////////////////////////////////////////////////////////////////////////////

  const confidentialToken = useMemo(() => {
    // If we have a looked up token address from registry, use it
    if (lookedUpTokenAddress) {
      const c = {
        address: lookedUpTokenAddress as `0x${string}`,
        chainId: chainId!,
        chainName: getNetworkName(chainId!),
        abi: ConfidentialTokenExtendedABI.abi,
      };
      confidentialTokenRef.current = c;
      return c;
    }

    // Otherwise, use the default lookup
    const c = getConfidentialTokenByChainId(chainId);
    confidentialTokenRef.current = c;

    if (!c.address) {
      setMessage(`ConfidentialToken deployment not found for chainId=${chainId}.`);
    }

    return c;
  }, [chainId, lookedUpTokenAddress]);

  // List all slugs for a user
  const listUserSlugs = useCallback(async (ownerAddress: string) => {
    if (!chainId || !ethersReadonlyProvider) return [];
    
    try {
      const registryEntry = CTRegistryAddresses[chainId.toString() as keyof typeof CTRegistryAddresses];
      if (!registryEntry || registryEntry.address === "0x0000000000000000000000000000000000000000") {
        return [];
      }

      const registry = new (await import("ethers")).Contract(
        registryEntry.address,
        CTRegistryABI.abi,
        ethersReadonlyProvider
      );

      // Try common slugs
      const commonSlugs = ["main", "tomcat2389", "test", "dev", "prod", "contract1", "contract2", "mycontract", "token1", "token2"];
      const foundSlugs: string[] = [];
      
      for (const slug of commonSlugs) {
        try {
          const count = await registry.count(ownerAddress, slug);
          console.log(`[Registry] Slug "${slug}": ${count} versions`);
          if (count > 0) {
            foundSlugs.push(slug);
            // Get latest contract address for this slug
            try {
              const latest = await registry.latest(ownerAddress, slug);
              console.log(`[Registry] Latest contract for "${slug}": ${latest}`);
            } catch (error) {
              console.log(`[Registry] Failed to get latest for "${slug}":`, error);
            }
          }
        } catch (error) {
          // Ignore errors for non-existent slugs
        }
      }
      
      return foundSlugs;
    } catch (error) {
      console.error("[Registry] Failed to list slugs:", error);
      return [];
    }
  }, [chainId, ethersReadonlyProvider]);

  // Lookup contract from Registry
  const lookupFromRegistry = useCallback(async (ownerAddress: string, slug: string = "main") => {
    if (!chainId || !ethersReadonlyProvider) return null;
    
    try {
      const registryEntry = CTRegistryAddresses[chainId.toString() as keyof typeof CTRegistryAddresses];
      if (!registryEntry || registryEntry.address === "0x0000000000000000000000000000000000000000") {
        console.log("[Registry] No registry entry found for chainId:", chainId);
        return null;
      }

      console.log("[Registry] Looking up:", {
        registryAddress: registryEntry.address,
        ownerAddress: ownerAddress,
        slug: slug,
        chainId: chainId
      });

      const registry = new (await import("ethers")).Contract(
        registryEntry.address,
        CTRegistryABI.abi,
        ethersReadonlyProvider
      );

      try {
        const tokenAddress = await registry.latest(ownerAddress, slug);
        console.log("[Registry] Found contract:", tokenAddress);
        return tokenAddress;
      } catch (error: any) {
        // If no entry found, return null instead of throwing
        if (error.message?.includes("No entry") || error.code === "BAD_DATA") {
          console.log("[Registry] No contract found for owner:", ownerAddress, "slug:", slug);
          return null;
        }
        console.error("[Registry] Lookup error:", error);
        throw error;
      }
    } catch (error) {
      console.error("[Registry] Registry lookup failed:", error);
      return null;
    }
  }, [chainId, ethersReadonlyProvider]);

  // Load available slugs when user address is available
  useEffect(() => {
    if (ethersSigner?.address && chainId) {
      // Try to load from localStorage first
      const cacheKey = `slugs_${ethersSigner.address}_${chainId}`;
      const cachedSlugs = localStorage.getItem(cacheKey);
      
      if (cachedSlugs) {
        try {
          const parsed = JSON.parse(cachedSlugs);
          setAvailableSlugs(parsed);
          console.log("[useConfidentialToken] Loaded cached slugs:", parsed);
        } catch (error) {
          console.error("[useConfidentialToken] Failed to parse cached slugs:", error);
        }
      }
      
      // Always fetch fresh data
      listUserSlugs(ethersSigner.address).then((slugs) => {
        setAvailableSlugs(slugs);
        console.log("[useConfidentialToken] Available slugs:", slugs);
        
        // Cache the results
        localStorage.setItem(cacheKey, JSON.stringify(slugs));
      });
    }
  }, [ethersSigner?.address, chainId, listUserSlugs]);

  // Try to lookup from Registry when user address is available
  useEffect(() => {
    if (ethersSigner?.address && chainId) {
      console.log("[useConfidentialToken] Looking up contract from Registry...");
      console.log("[useConfidentialToken] Account:", ethersSigner.address);
      console.log("[useConfidentialToken] Slug:", debouncedSlug);
      lookupFromRegistry(ethersSigner.address, debouncedSlug).then((address) => {
        if (address && address !== "0x0000000000000000000000000000000000000000") {
          console.log("[useConfidentialToken] Found contract in Registry:", address);
          setLookedUpTokenAddress(address);
          // Force update confidentialTokenRef
          confidentialTokenRef.current = {
            address: address as `0x${string}`,
            chainId: chainId,
            chainName: getNetworkName(chainId),
            abi: ConfidentialTokenExtendedABI.abi,
          };
          // Clear any error messages
          setMessage("");
          
          // Check if current user is owner
          if (ethersReadonlyProvider) {
            (async () => {
              try {
                const { Contract } = await import("ethers");
                const contract = new Contract(
                  address,
                  ConfidentialTokenFixedABI.abi,
                  ethersReadonlyProvider
                );
                const owner = await contract.owner();
                setContractOwner(owner);
                setIsOwner(owner.toLowerCase() === ethersSigner.address.toLowerCase());
                console.log("[useConfidentialToken] Contract owner:", owner);
                console.log("[useConfidentialToken] Is current user owner:", owner.toLowerCase() === ethersSigner.address.toLowerCase());
              } catch (error) {
                console.error("[useConfidentialToken] Failed to get owner:", error);
              }
            })();
          }
        } else {
          console.log("[useConfidentialToken] No contract found in Registry for slug:", debouncedSlug);
        }
      });
    }
  }, [ethersSigner?.address, chainId, lookupFromRegistry, debouncedSlug]);

  //////////////////////////////////////////////////////////////////////////////
  // Contract Status
  //////////////////////////////////////////////////////////////////////////////

  const isDeployed = useMemo(() => {
    if (!confidentialToken) {
      return undefined;
    }
    return Boolean(confidentialToken.address) && confidentialToken.address !== ethers.ZeroAddress;
  }, [confidentialToken]);

  const canGetBalance = useMemo(() => {
    return confidentialToken.address && ethersReadonlyProvider && !isRefreshing;
  }, [confidentialToken.address, ethersReadonlyProvider, isRefreshing]);

  //////////////////////////////////////////////////////////////////////////////
  // Balance Handle
  //////////////////////////////////////////////////////////////////////////////

  const refreshBalanceHandle = useCallback(() => {
    console.log("[useConfidentialToken] call refreshBalanceHandle()");
    if (isRefreshingRef.current) {
      return;
    }

    if (
      !confidentialTokenRef.current ||
      !confidentialTokenRef.current?.chainId ||
      !confidentialTokenRef.current?.address ||
      !ethersReadonlyProvider ||
      !ethersSigner
    ) {
      setBalanceHandle(undefined);
      return;
    }

    isRefreshingRef.current = true;
    setIsRefreshing(true);

    const thisChainId = confidentialTokenRef.current.chainId;
    const thisTokenAddress = confidentialTokenRef.current.address;

    const thisTokenContract = new ethers.Contract(
      thisTokenAddress,
      confidentialTokenRef.current.abi,
      ethersReadonlyProvider
    );

    // Debug: Log contract details
    const abiFunctions = confidentialTokenRef.current.abi.filter((item: any) => item.type === 'function').map((item: any) => item.name);
    console.log("[DEBUG] Contract details:", {
      address: thisTokenAddress,
      chainId: thisChainId,
      abiLength: confidentialTokenRef.current.abi.length,
      hasGetEncryptedBalance: !!thisTokenContract.getEncryptedBalance,
      abiFunctions: abiFunctions,
      contractMethods: thisTokenContract.interface?.functions ? Object.getOwnPropertyNames(thisTokenContract.interface.functions) : "No interface.functions"
    });

    // Check if contract has getEncryptedBalance function
    if (!thisTokenContract.getEncryptedBalance) {
      console.error("[useConfidentialToken] Contract does not have getEncryptedBalance function");
      console.error("[DEBUG] Available functions:", thisTokenContract.interface?.functions ? Object.getOwnPropertyNames(thisTokenContract.interface.functions) : "No interface.functions");
      setMessage("Contract ABI mismatch - missing getEncryptedBalance function");
      setIsRefreshing(false);
      isRefreshingRef.current = false;
      return;
    }

    // Get encrypted balance handle
    thisTokenContract
      .getEncryptedBalance(ethersSigner.address)
      .then((value) => {
        console.log("[useConfidentialToken] getEncryptedBalance()=" + value);
        if (
          sameChain.current(thisChainId) &&
          thisTokenAddress === confidentialTokenRef.current?.address
        ) {
          setBalanceHandle(value);
        }

        isRefreshingRef.current = false;
        setIsRefreshing(false);
      })
      .catch((e) => {
        setMessage("ConfidentialToken.getEncryptedBalance() call failed! error=" + e);
        isRefreshingRef.current = false;
        setIsRefreshing(false);
      });
  }, [ethersReadonlyProvider, ethersSigner, sameChain]);

  // Remove auto-refresh to prevent infinite loop
  // Balance will only be refreshed when user clicks "Refresh Balance" button

  //////////////////////////////////////////////////////////////////////////////
  // Balance Decryption
  //////////////////////////////////////////////////////////////////////////////

  const canDecrypt = useMemo(() => {
    return (
      confidentialToken.address &&
      instance &&
      ethersSigner &&
      !isRefreshing &&
      !isDecrypting &&
      balanceHandle &&
      balanceHandle !== ethers.ZeroHash &&
      balanceHandle !== clearBalance?.handle
    );
  }, [
    confidentialToken.address,
    instance,
    ethersSigner,
    isRefreshing,
    isDecrypting,
    balanceHandle,
    clearBalance,
  ]);

  const decryptBalanceHandle = useCallback(() => {
    if (isRefreshingRef.current || isDecryptingRef.current) {
      return;
    }

    if (!confidentialToken.address || !instance || !ethersSigner) {
      return;
    }

    if (balanceHandle === clearBalanceRef.current?.handle) {
      return;
    }

    if (!balanceHandle) {
      setClearBalance(undefined);
      clearBalanceRef.current = undefined;
      return;
    }

    if (balanceHandle === ethers.ZeroHash) {
      setClearBalance({ handle: balanceHandle, clear: BigInt(0) });
      clearBalanceRef.current = { handle: balanceHandle, clear: BigInt(0) };
      return;
    }

    const thisChainId = chainId;
    const thisTokenAddress = confidentialToken.address;
    const thisBalanceHandle = balanceHandle;
    const thisEthersSigner = ethersSigner;

    isDecryptingRef.current = true;
    setIsDecrypting(true);
    setMessage("Start decrypt balance");

    const run = async () => {
      const isStale = () =>
        thisTokenAddress !== confidentialTokenRef.current?.address ||
        !sameChain.current(thisChainId) ||
        !sameSigner.current(thisEthersSigner);

      try {
        // 0) Ensure user has decrypt permission
        const tokenInfo = confidentialTokenRef.current;
        if (!tokenInfo || !tokenInfo.address) {
          setMessage("No contract available");
          return;
        }
        
        // Create contract instance to call allowSelfBalanceDecrypt
        const tokenContract = new ethers.Contract(
          tokenInfo.address,
          tokenInfo.abi,
          thisEthersSigner
        );
        
        // Call allowSelfBalanceDecrypt function
          console.log("Calling allowSelfBalanceDecrypt...");
          if (!tokenContract.allowSelfBalanceDecrypt) {
            throw new Error("Contract does not have allowSelfBalanceDecrypt function");
          }
          await tokenContract.allowSelfBalanceDecrypt();
          console.log("allowSelfBalanceDecrypt completed");

        // 1) Generate temporary keypair & EIP-712
        const keypair = instance.generateKeypair();
        const start = Math.floor(Date.now() / 1000).toString();
        const durationDays = "7";

        const eip712 = instance.createEIP712(
          keypair.publicKey,
          [thisTokenAddress],
          start,
          durationDays
        );

        // 2) Sign typed data
        const sig = await thisEthersSigner.signTypedData(
          eip712.domain,
          { UserDecryptRequestVerification: eip712.types.UserDecryptRequestVerification },
          eip712.message
        );

        if (isStale()) {
          setMessage("Ignore FHEVM decryption");
          return;
        }

        setMessage("Call FHEVM userDecrypt...");

        // 3) Call userDecrypt
        const res = await instance.userDecrypt(
          [{ handle: thisBalanceHandle, contractAddress: thisTokenAddress }],
          keypair.privateKey,
          keypair.publicKey,
          sig.replace("0x", ""),
          [thisTokenAddress],
          await thisEthersSigner.getAddress(),
          start,
          durationDays
        );

        setMessage("FHEVM userDecrypt completed!");

        if (isStale()) {
          setMessage("Ignore FHEVM decryption");
          return;
        }

        setClearBalance({ handle: thisBalanceHandle, clear: res[thisBalanceHandle] });
        clearBalanceRef.current = {
          handle: thisBalanceHandle,
          clear: res[thisBalanceHandle],
        };

        setMessage("Balance decrypted: " + clearBalanceRef.current.clear);
      } finally {
        isDecryptingRef.current = false;
        setIsDecrypting(false);
      }
    };

    run();
  }, [
    fhevmDecryptionSignatureStorage,
    ethersSigner,
    confidentialToken.address,
    instance,
    balanceHandle,
    chainId,
    sameChain,
    sameSigner,
  ]);

  //////////////////////////////////////////////////////////////////////////////
  // Initialize Address
  //////////////////////////////////////////////////////////////////////////////

  const canInitialize = useMemo(() => {
    return (
      confidentialToken.address &&
      ethersSigner &&
      !isInitializing
    );
  }, [confidentialToken.address, ethersSigner, isInitializing]);

  const initializeAddress = useCallback((address: string) => {
    if (isInitializingRef.current) {
      return;
    }

    if (!confidentialToken.address || !ethersSigner) {
      return;
    }

    const thisChainId = chainId;
    const thisTokenAddress = confidentialToken.address;
    const thisEthersSigner = ethersSigner;

    const tokenContract = new ethers.Contract(
      thisTokenAddress,
      confidentialToken.abi,
      thisEthersSigner
    );

    isInitializingRef.current = true;
    setIsInitializing(true);
    setMessage(`Initializing address ${address}...`);

    const run = async () => {
      const isStale = () =>
        thisTokenAddress !== confidentialTokenRef.current?.address ||
        !sameChain.current(thisChainId) ||
        !sameSigner.current(thisEthersSigner);

      try {
        if (!tokenContract.initializeAddress) {
          throw new Error("Contract does not have initializeAddress function");
        }
        const tx = await tokenContract.initializeAddress(address);
        setMessage(`Wait for tx:${tx.hash}...`);

        const receipt = await tx.wait();
        setMessage(`Address initialized! status=${receipt?.status}`);

        if (isStale()) {
          setMessage("Ignore initialization");
          return;
        }

        refreshBalanceHandle();
      } catch (e) {
        setMessage(`Initialization failed: ${e}`);
      } finally {
        isInitializingRef.current = false;
        setIsInitializing(false);
      }
    };

    run();
  }, [
    ethersSigner,
    confidentialToken.address,
    confidentialToken.abi,
    chainId,
    refreshBalanceHandle,
    sameChain,
    sameSigner,
  ]);

  //////////////////////////////////////////////////////////////////////////////
  // Mint Confidential Tokens
  //////////////////////////////////////////////////////////////////////////////

  const canMint = useMemo(() => {
    return (
      confidentialToken.address &&
      instance &&
      ethersSigner &&
      isOwner &&
      !isRefreshing &&
      !isMinting
    );
  }, [confidentialToken.address, instance, ethersSigner, isOwner, isRefreshing, isMinting]);

  const mintConfidential = useCallback((to: string, amount: number) => {
    if (isRefreshingRef.current || isMintingRef.current) {
      return;
    }

    if (!confidentialToken.address || !ethersSigner || amount <= 0) {
      setMessage("Missing required parameters for minting");
      return;
    }

    if (!instance) {
      setMessage("FHEVM instance not ready. Please wait for initialization or use bypass mode.");
      return;
    }

    const thisChainId = chainId;
    const thisTokenAddress = confidentialToken.address;
    const thisEthersSigner = ethersSigner;

    const tokenContract = new ethers.Contract(
      thisTokenAddress,
      confidentialToken.abi,
      thisEthersSigner
    );

    isMintingRef.current = true;
    setIsMinting(true);
    setMessage(`Minting ${amount} tokens to ${to}...`);

    const run = async () => {
      await new Promise((resolve) => setTimeout(resolve, 100));

      const isStale = () =>
        thisTokenAddress !== confidentialTokenRef.current?.address ||
        !sameChain.current(thisChainId) ||
        !sameSigner.current(thisEthersSigner);

      try {
        console.log("[DEBUG] Creating encrypted input...");
        console.log("[DEBUG] Contract address:", thisTokenAddress);
        console.log("[DEBUG] User address:", thisEthersSigner.address);
        console.log("[DEBUG] Amount:", amount);
        console.log("[DEBUG] Chain ID:", thisChainId);
        
        // Use getAddress() instead of .address for proper async handling
        const from = await thisEthersSigner.getAddress();
        console.log("[DEBUG] From address (async):", from);
        
        // Debug: Log all context before encrypt
        console.log("[DEBUG] ENC.contract =", thisTokenAddress);
        console.log("[DEBUG] ENC.user     =", from);
        console.log("[DEBUG] tx.to        =", tokenContract.target);
        console.log("[DEBUG] chainId      =", thisChainId);
        
        const input = instance.createEncryptedInput(
          thisTokenAddress,
          from
        );
        // Use parseUnits to properly scale amount with contract decimals
        const scaledAmount = parseUnits(amount.toString(), 6); // Contract has 6 decimals
        console.log("[DEBUG] Scaled amount (BigInt):", scaledAmount);
        console.log("[DEBUG] Scaled amount (human readable):", formatUnits(scaledAmount, 6), "CT");
        
        // No amount limit - token has infinite supply
        input.add64(scaledAmount);

        console.log("[DEBUG] Encrypting input...");
        const enc = await input.encrypt();
        console.log("[DEBUG] Encryption successful:", enc);

        if (isStale()) {
          setMessage("Ignore mint");
          return;
        }

        setMessage(`Call mintConfidential...`);

        // Debug: Log contract details for mint
        const abiFunctions = confidentialTokenRef.current.abi.filter((item: any) => item.type === 'function').map((item: any) => item.name);
        console.log("[DEBUG] Mint contract details:", {
          address: thisTokenAddress,
          chainId: thisChainId,
          abiLength: confidentialTokenRef.current.abi.length,
          hasMintConfidential: !!tokenContract.mintConfidential,
          abiFunctions: abiFunctions,
          contractMethods: tokenContract.interface?.functions ? Object.getOwnPropertyNames(tokenContract.interface.functions) : "No interface.functions"
        });

        // Check if contract has mintConfidential function
        if (!tokenContract.mintConfidential) {
          console.error("[DEBUG] Available functions:", tokenContract.interface?.functions ? Object.getOwnPropertyNames(tokenContract.interface.functions) : "No interface.functions");
          throw new Error("Contract does not have mintConfidential function");
        }

        const tx = await tokenContract.mintConfidential(
          to,
          enc.handles[0],
          enc.inputProof
        );

        setMessage(`Wait for tx:${tx.hash}...`);

        const receipt = await tx.wait();
        setMessage(`Mint completed! status=${receipt?.status}`);

        if (isStale()) {
          setMessage("Ignore mint");
          return;
        }

        refreshBalanceHandle();
      } catch (e) {
        setMessage(`Mint failed: ${e}`);
      } finally {
        isMintingRef.current = false;
        setIsMinting(false);
      }
    };

    run();
  }, [
    ethersSigner,
    confidentialToken.address,
    confidentialToken.abi,
    instance,
    chainId,
    refreshBalanceHandle,
    sameChain,
    sameSigner,
  ]);

  // Fallback mint function without FHEVM (for testing)
  const mintConfidentialFallback = useCallback((to: string, amount: number) => {
    if (isRefreshingRef.current || isMintingRef.current) {
      return;
    }

    if (!confidentialToken.address || !ethersSigner || amount <= 0) {
      setMessage("Missing required parameters for minting");
      return;
    }

    const thisChainId = chainId;
    const thisTokenAddress = confidentialToken.address;
    const thisEthersSigner = ethersSigner;

    const tokenContract = new ethers.Contract(
      thisTokenAddress,
      confidentialToken.abi,
      thisEthersSigner
    );

    isMintingRef.current = true;
    setIsMinting(true);
    setMessage(`[FALLBACK] Testing mint connection...`);

    const run = async () => {
      try {
        // Try to call a simple function first to test connection
        if (!tokenContract.owner) {
          throw new Error("Contract does not have owner function");
        }
        const owner = await tokenContract.owner();
        console.log("[FALLBACK] Contract owner:", owner);
        
        if (owner.toLowerCase() !== thisEthersSigner.address.toLowerCase()) {
          setMessage("You are not the contract owner");
          return;
        }

        // For now, just show success message
        setMessage(`[FALLBACK] Connection OK! Would mint ${amount} tokens to ${to}. FHEVM required for actual minting.`);
        
      } catch (e: any) {
        setMessage(`[FALLBACK] Connection test failed: ${e.message}`);
        console.error("[FALLBACK] Error:", e);
      } finally {
        isMintingRef.current = false;
        setIsMinting(false);
      }
    };

    run();
  }, [
    ethersSigner,
    confidentialToken.address,
    confidentialToken.abi,
    chainId,
    sameChain,
    sameSigner,
  ]);

  //////////////////////////////////////////////////////////////////////////////
  // Transfer Confidential Tokens
  //////////////////////////////////////////////////////////////////////////////

  const canTransfer = useMemo(() => {
    return (
      confidentialToken.address &&
      instance &&
      ethersSigner &&
      !isRefreshing &&
      !isTransferring
    );
  }, [confidentialToken.address, instance, ethersSigner, isRefreshing, isTransferring]);

  const transferConfidential = useCallback((to: string, amount: number) => {
    if (isRefreshingRef.current || isTransferringRef.current) {
      return;
    }

    if (!confidentialToken.address || !instance || !ethersSigner || amount <= 0) {
      return;
    }

    const thisChainId = chainId;
    const thisTokenAddress = confidentialToken.address;
    const thisEthersSigner = ethersSigner;

    const tokenContract = new ethers.Contract(
      thisTokenAddress,
      confidentialToken.abi,
      thisEthersSigner
    );

    isTransferringRef.current = true;
    setIsTransferring(true);
    setMessage(`Transferring ${amount} tokens to ${to}...`);

    const run = async () => {
      await new Promise((resolve) => setTimeout(resolve, 100));

      const isStale = () =>
        thisTokenAddress !== confidentialTokenRef.current?.address ||
        !sameChain.current(thisChainId) ||
        !sameSigner.current(thisEthersSigner);

      try {
        // Use getAddress() instead of .address for proper async handling
        const from = await thisEthersSigner.getAddress();
        
        // Debug: Log all context before encrypt
        console.log("[DEBUG] TRANSFER - ENC.contract =", thisTokenAddress);
        console.log("[DEBUG] TRANSFER - ENC.user     =", from);
        console.log("[DEBUG] TRANSFER - tx.to        =", tokenContract.target);
        console.log("[DEBUG] TRANSFER - chainId      =", thisChainId);
        
        const input = instance.createEncryptedInput(
          thisTokenAddress,
          from
        );
        // Use parseUnits to properly scale amount with contract decimals
        const scaledAmount = parseUnits(amount.toString(), 6); // Contract has 6 decimals
        console.log("[DEBUG] TRANSFER - Scaled amount:", scaledAmount);
        input.add64(scaledAmount);

        const enc = await input.encrypt();

        if (isStale()) {
          setMessage("Ignore transfer");
          return;
        }

        setMessage(`Call transferConfidential...`);

        // Check if contract has transferConfidential function
        if (!tokenContract.transferConfidential) {
          throw new Error("Contract does not have transferConfidential function");
        }

        const tx = await tokenContract.transferConfidential(
          to,
          enc.handles[0],
          enc.inputProof
        );

        setMessage(`Wait for tx:${tx.hash}...`);

        const receipt = await tx.wait();
        setMessage(`Transfer completed! status=${receipt?.status}`);

        if (isStale()) {
          setMessage("Ignore transfer");
          return;
        }

        refreshBalanceHandle();
      } catch (e) {
        setMessage(`Transfer failed: ${e}`);
      } finally {
        isTransferringRef.current = false;
        setIsTransferring(false);
      }
    };

    run();
  }, [
    ethersSigner,
    confidentialToken.address,
    confidentialToken.abi,
    instance,
    chainId,
    refreshBalanceHandle,
    sameChain,
    sameSigner,
  ]);

  // Reset decryption session
  const resetDecryptSession = useCallback(() => {
    fhevmDecryptionSignatureStorage.resetAll([
      "priv", "pub", "sig", "user", "start", "days"
    ]);
    setClearBalance(undefined);
    setMessage("Decryption session reset. Please try again.");
  }, [fhevmDecryptionSignatureStorage]);

  return {
    contractAddress: confidentialToken.address,
    canDecrypt,
    canGetBalance,
    canInitialize,
    canMint,
    canTransfer,
    initializeAddress,
    mintConfidential,
    mintConfidentialFallback,
    transferConfidential,
    decryptBalanceHandle,
    refreshBalanceHandle,
    resetDecryptSession,
    isDecrypted,
    message,
    clear: clearBalance?.clear,
    handle: balanceHandle,
    isDecrypting,
    isRefreshing,
    isMinting,
    isTransferring,
    isInitializing,
    isDeployed,
    isOwner,
    contractOwner,
    currentSlug,
    setCurrentSlug,
    availableSlugs,
    setAvailableSlugs,
  };
};
